utf8_decode :: inline (buffer : []u8) -> codepoint : u32, units_read : s64
#no_abc
{
	// https://github.com/gingerBill/gb/blob/master/gb.h
	UTF8_FIRST :: u8.[
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x00-0x0F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x10-0x1F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x20-0x2F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x30-0x3F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x40-0x4F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x50-0x5F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x60-0x6F
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x70-0x7F
		0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x80-0x8F
		0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x90-0x9F
		0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xA0-0xAF
		0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xB0-0xBF
		0xf1, 0xf1, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xC0-0xCF
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xD0-0xDF
		0x13, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x23, 0x03, 0x03, // 0xE0-0xEF
		0x34, 0x04, 0x04, 0x04, 0x44, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xF0-0xFF
	];

	UTF8_Accept_Range :: struct
	{
		lo, hi : u8;
	}

	UTF8_ACCEPT_RANGES :: UTF8_Accept_Range.[
		UTF8_Accept_Range.{ 0x80, 0xbf },
		UTF8_Accept_Range.{ 0xa0, 0xbf },
		UTF8_Accept_Range.{ 0x80, 0x9f },
		UTF8_Accept_Range.{ 0x90, 0xbf },
		UTF8_Accept_Range.{ 0x80, 0x8f }
	];

	if buffer.count > 0
	{
		b0 := buffer[0];
		x  := UTF8_FIRST[b0];
		
		if x >= 0xf0
		{
			mask := (cast (u32) x << 31) >> 31;
			
			return (cast (u32) b0 & (~mask)) | (UNICODE_INVALID & mask), 1;
		}
		else if b0 < 0x80
		{
			return b0, 1;
		}

		sz := x & 7;
		if buffer.count < 2
			return UNICODE_INVALID, 1;
		b1 := buffer[1];
		range := UTF8_ACCEPT_RANGES[x >> 4];
		if b1 < range.lo || b1 > range.hi then return UNICODE_INVALID, 1;

		if sz == 2
			return ((cast (u32) b0 & 0x1f) << 6) | (cast (u32) b1 & 0x3f), 2;

		if buffer.count < 3
			return UNICODE_INVALID, 2;
		b2 := buffer[2];
		if b2 < 0x80 || b2 > 0xbf then return UNICODE_INVALID, 1;

		if sz == 3
			return ((cast (u32) b0 & 0x1f) << 12) | ((cast (u32) b1 & 0x3f) << 6) | (cast (u32) b2 & 0x3f), 3;

		if buffer.count < 4
			return UNICODE_INVALID, 3;
		b3 := buffer[3];
		if b3 < 0x80 || b3 > 0xbf then return UNICODE_INVALID, 1;

		return ((cast (u32) b0 & 0x07) << 18) | ((cast (u32) b1 & 0x3f) << 12) | ((cast (u32) b2 & 0x3f) << 6) | ((cast (u32) b3 & 0x3f)), 4;
	}

	return UNICODE_INVALID, 0;
}

utf8_encode :: inline (buffer : []u8, codepoint : u32) -> length : s64, written : s64
	#no_abc
{
	i := codepoint;
	MASK : u8 : 0x3f;
	written := 0;

	if i <= (1 << 7) - 1
	{
		if buffer.count > 0
		{
			buffer[0] = cast (u8) codepoint;
			written += 1;
		}

		return 1, written;
	}
	else if i <= (1 << 11) - 1
	{
		if buffer.count > 0
		{
			buffer[0] = 0xc0 |  cast (u8) (codepoint >> 6);
			written += 1;
		}
		if buffer.count > 1
		{
			buffer[1] = 0x80 | (cast (u8) (codepoint) & MASK);
			written += 1;
		}

		return 2, written;
	}
	else if i > UNICODE_MAX || (i >= 0xd800 && i <= 0xdfff)
	{
		codepoint = UNICODE_INVALID;
		if buffer.count > 0
		{
			buffer[0] = 0xe0 |  cast (u8) (codepoint >> 12);
			written += 1;
		}
		if buffer.count > 1
		{
			buffer[1] = 0x80 | (cast (u8) (codepoint >> 6) & MASK);
			written += 1;
		}
		if buffer.count > 2
		{
			buffer[2] = 0x80 | (cast (u8) (codepoint) & MASK);
			written += 1;
		}

		return 3, written;
	}
	else if i <= (1 << 16) - 1
	{
		if buffer.count > 0
		{
			buffer[0] = 0xe0 |  cast (u8) (codepoint >> 12);
			written += 1;
		}
		if buffer.count > 1
		{
			buffer[1] = 0x80 | (cast (u8) (codepoint >> 6) & MASK);
			written += 1;
		}
		if buffer.count > 2
		{
			buffer[2] = 0x80 | (cast (u8) (codepoint) & MASK);
			written += 1;
		}

		return 3, written;
	}
	else
	{
		if buffer.count > 0
		{
			buffer[0] = 0xf0 |  cast (u8) (codepoint >> 18);
			written += 1;
		}
		if buffer.count > 1
		{
			buffer[1] = 0x80 | (cast (u8) (codepoint >> 12) & MASK);
			written += 1;
		}
		if buffer.count > 2
		{
			buffer[2] = 0x80 | (cast (u8) (codepoint >> 6) & MASK);
			written += 1;
		}
		if buffer.count > 3
		{
			buffer[3] = 0x80 | (cast (u8) (codepoint) & MASK);
			written += 1;
		}

		return 4, written;
	}
}

utf8_encoding_length :: inline (codepoint : u32) -> s64 #must
{
	if codepoint <= 0x7f
		return 1;
	else if codepoint <= 0x7ff
		return 2;
	else if codepoint <= 0xffff
		return 3;
	else if codepoint <= 0x1fffff
		return 4;
	
	return 0;
}
